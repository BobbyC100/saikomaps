generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model activity_spots {
  id          String     @id
  name        String
  slug        String?    @unique
  latitude    Float
  longitude   Float
  layer_type  LayerType
  city        String?
  region      String?
  country     String     @default("US")
  spot_type   String?
  tags        String[]
  surface     String?
  skill_level String?
  exposure    String?
  description String?
  seasonality String?
  is_public   Boolean    @default(true)
  source      SpotSource
  source_id   String?
  source_url  String?
  verified    Boolean    @default(false)
  enabled     Boolean    @default(true)
  created_at  DateTime   @default(now())
  updated_at  DateTime

  @@index([layer_type, city])
  @@index([layer_type, latitude, longitude])
  @@index([source, source_id])
}

model import_jobs {
  id                 String    @id
  userId             String    @map("user_id")
  listId             String?   @map("list_id")
  status             String    @default("processing")
  totalLocations     Int?      @map("total_locations")
  processedLocations Int       @default(0) @map("processed_locations")
  failedLocations    Int       @default(0) @map("failed_locations")
  errorLog           Json?     @map("error_log")
  createdAt          DateTime  @default(now()) @map("created_at")
  completedAt        DateTime? @map("completed_at")
  lists              lists?    @relation(fields: [listId], references: [id])
  users              users     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([userId])
}

model lists {
  id                  String           @id
  userId              String           @map("user_id")
  title               String
  subtitle            String?
  description         String?
  descriptionSource   String?          @map("description_source")
  slug                String           @unique
  introText           String?          @map("intro_text")
  functionType        String?          @map("function_type")
  functionContext     String?          @map("function_context")
  scopeGeography      String?          @map("scope_geography")
  scopePlaceTypes     String[]         @map("scope_place_types")
  scopeExclusions     String[]         @map("scope_exclusions")
  organizingLogic     OrganizingLogic? @map("organizing_logic")
  organizingLogicNote String?          @map("organizing_logic_note")
  notes               String?
  status              MapStatus        @default(DRAFT)
  publishedAt         DateTime?        @map("published_at")
  templateType        String           @default("field-notes") @map("template_type")
  coverImageUrl       String?          @map("cover_image_url")
  primaryColor        String           @default("#5BA7A7") @map("primary_color")
  secondaryColor      String           @default("#7FA5A5") @map("secondary_color")
  accessLevel         String           @default("public") @map("access_level")
  passwordHash        String?          @map("password_hash")
  allowedEmails       String[]         @map("allowed_emails")
  published           Boolean          @default(false)
  viewCount           Int              @default(0) @map("view_count")
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @map("updated_at")
  import_jobs         import_jobs[]
  users               users            @relation(fields: [userId], references: [id], onDelete: Cascade)
  locations           locations[]
  map_places          map_places[]
  saved_maps          saved_maps[]

  @@index([published])
  @@index([slug])
  @@index([status])
  @@index([userId])
}

model locations {
  id                 String    @id
  listId             String    @map("list_id")
  googlePlaceId      String?   @map("google_place_id")
  name               String
  address            String?
  latitude           Decimal?  @db.Decimal(10, 8)
  longitude          Decimal?  @db.Decimal(11, 8)
  phone              String?
  website            String?
  instagram          String?
  hours              Json?
  description        String?
  googleTypes        String[]  @default([]) @map("google_types")
  priceLevel         Int?      @map("price_level")
  neighborhood       String?
  googlePhotos       Json?     @map("google_photos")
  userPhotos         String[]  @map("user_photos")
  userNote           String?   @map("user_note")
  category           String?
  descriptor         String?
  orderIndex         Int       @default(0) @map("order_index")
  placesDataCachedAt DateTime? @map("places_data_cached_at")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @map("updated_at")
  lists              lists     @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@index([googlePlaceId])
  @@index([listId, category])
  @@index([listId])
  @@index([listId, orderIndex])
}

model map_places {
  id         String   @id
  mapId      String   @map("map_id")
  entityId   String   @map("entity_id")
  descriptor String?  @db.VarChar(120)
  userNote   String?  @map("user_note")
  userPhotos String[] @map("user_photos")
  orderIndex Int      @default(0) @map("order_index")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @map("updated_at")
  lists      lists    @relation(fields: [mapId], references: [id], onDelete: Cascade)
  entities   entities @relation(fields: [entityId], references: [id])

  @@unique([mapId, entityId])
  @@index([mapId])
  @@index([mapId, orderIndex])
  @@index([entityId])
}

model categories {
  id        String  @id @default(cuid())
  slug      String  @unique
  label     String
  is_active Boolean @default(true)

  entities entities[]
}

model people {
  id                  String             @id
  name                String
  slug                String             @unique
  role                PersonRole
  visibility          Visibility
  bio                 String?
  image_url           String?
  sources             Json
  restaurant_group_id String?
  created_at          DateTime           @default(now())
  updated_at          DateTime
  restaurant_groups   restaurant_groups? @relation(fields: [restaurant_group_id], references: [id])
  person_places       person_places[]

  @@index([restaurant_group_id])
  @@index([slug])
  @@index([visibility])
}

model person_places {
  id         String          @id
  person_id  String
  entityId   String          @map("entity_id")
  role       PersonPlaceRole
  current    Boolean         @default(true)
  start_year Int?
  end_year   Int?
  source     String
  created_at DateTime        @default(now())
  updated_at DateTime
  people     people          @relation(fields: [person_id], references: [id], onDelete: Cascade)
  entities   entities        @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([person_id, entityId, role])
  @@index([current])
  @@index([person_id])
  @@index([entityId])
}

model entities {
  id                     String             @id
  slug                   String             @unique
  googlePlaceId          String?            @unique @map("google_place_id")
  name                   String
  address                String?
  latitude               Decimal?           @db.Decimal(10, 8)
  longitude              Decimal?           @db.Decimal(11, 8)
  phone                  String?
  website                String?
  instagram              String?
  hours                  Json?
  description            String?
  googlePhotos           Json?              @map("google_photos")
  googleTypes            String[]           @default([]) @map("google_types")
  priceLevel             Int?               @map("price_level")
  neighborhood           String?
  category               String?
  primary_vertical       PrimaryVertical     @map("primary_vertical")
  placesDataCachedAt     DateTime?           @map("places_data_cached_at")
  createdAt              DateTime           @default(now()) @map("created_at")
  updatedAt              DateTime           @updatedAt @map("updated_at")
  editorialSources       Json?              @map("editorial_sources")
  cuisineType            String?            @map("cuisine_type")
  adUnitOverride         Boolean            @default(false) @map("ad_unit_override")
  adUnitType             String?            @map("ad_unit_type")
  pullQuote              String?            @map("pull_quote")
  pullQuoteAuthor        String?            @map("pull_quote_author")
  pullQuoteSource        String?            @map("pull_quote_source")
  pullQuoteType          String?            @map("pull_quote_type")
  pullQuoteUrl           String?            @map("pull_quote_url")
  tagline                String?
  taglineCandidates      String[]           @default([]) @map("tagline_candidates")
  taglineGenerated       DateTime?          @map("tagline_generated")
  taglinePattern         String?            @map("tagline_pattern")
  taglineSignals         Json?              @map("tagline_signals")
  tips                   String[]           @default([])
  vibeTags               String[]           @default([]) @map("vibe_tags")
  transitAccessible      Boolean?           @map("transit_accessible")
  thematicTags           String[]           @default([]) @map("thematic_tags")
  contextualConnection   String?            @map("contextual_connection")
  curatorAttribution     String?            @map("curator_attribution")
  chefRecs               Json?              @map("chef_recs")
  restaurantGroupId      String?            @map("restaurant_group_id") // DEPRECATED: use place_actor_relationships. No new writes.
  status                 PlaceStatus        @default(OPEN)
  intentProfile          String?            @map("intent_profile")
  intentProfileOverride  Boolean            @default(false) @map("intent_profile_override")
  reservationUrl         String?            @map("reservation_url")
  businessStatus         String?            @map("business_status") // from Google; 'CLOSED_PERMANENTLY' excluded from coverage
  googlePlacesAttributes Json?              @map("google_places_attributes")
  entityType             PlaceType          @default(venue) @map("entity_type")
  categoryId             String?            @map("category_id")
  parentId               String?            @map("parent_id")
  marketSchedule         Json?              @map("market_schedule")
  prlOverride            Int?               @map("prl_override") // 1-4 manual override; display PRL = override ?? computed
  map_places             map_places[]
  person_places          person_places[]
  restaurant_groups      restaurant_groups? @relation(fields: [restaurantGroupId], references: [id])
  category_rel           categories?        @relation(fields: [categoryId], references: [id])
  parent                 entities?          @relation("PlaceHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children               entities[]         @relation("PlaceHierarchy")
  viewer_bookmarks       viewer_bookmarks[]
  energy_scores          energy_scores[]
  place_tag_scores       place_tag_scores[]
  place_photo_eval       place_photo_eval[]
  place_coverage_status  place_coverage_status[]
  gpid_resolution_queue   gpid_resolution_queue[]
  place_actor_relationships PlaceActorRelationship[]
  operatorPlaceCandidates OperatorPlaceCandidate[]
  place_appearances_as_subject place_appearances[] @relation("AppearanceSubject")
  place_appearances_as_host    place_appearances[] @relation("AppearanceHost")

  // Confidence System v1: field-level JSONB, computed at sync (not at query time)
  confidence           Json?    // { field: { value, score, sources, winner, conflicts } }
  overall_confidence   Float?   @default(0.5) @map("overall_confidence")
  confidence_updated_at DateTime? @map("confidence_updated_at")

  // Website enrichment (SAIKO spec v1.1)
  last_enriched_at   DateTime? @map("last_enriched_at")
  enrichment_stage  String?   @map("enrichment_stage") // e.g. ENRICHED_WEBSITE
  needs_human_review Boolean  @default(false) @map("needs_human_review")
  category_enrich_attempted_at DateTime? @map("category_enrich_attempted_at") // throttle category-only re-enrich

  merchant_enrichment_runs merchant_enrichment_runs[]
  merchant_signals         merchant_signals?

  @@map("entities")
  @@index([category])
  @@index([categoryId])
  @@index([googlePlaceId])
  @@index([neighborhood])
  @@index([primary_vertical])
  @@index([parentId])
  @@index([restaurantGroupId])
  @@index([status])
  @@index([businessStatus])
  @@index([last_enriched_at])
  @@index([needs_human_review])
}

/// Website enrichment runs — append-only audit (SAIKO spec v1.1)
model merchant_enrichment_runs {
  id             String    @id @default(uuid())
  entityId       String    @map("entity_id")
  source_url     String    @map("source_url")
  final_url      String?   @map("final_url")
  fetched_at     DateTime  @default(now()) @map("fetched_at")
  http_status    Int?      @map("http_status")
  extraction_json Json     @default("{}") @map("extraction_json")
  confidence     Decimal?  @db.Decimal(4, 2)
  cost_usd       Decimal   @default(0) @map("cost_usd") @db.Decimal(10, 6)
  created_at     DateTime  @default(now()) @map("created_at")

  entities entities @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@index([entityId])
  @@index([fetched_at])
}

/// Merchant signals — current best per entity (upsert)
model merchant_signals {
  entityId               String   @id @map("entity_id")
  inferred_category      String?  @map("inferred_category")
  inferred_cuisine       Json?    @map("inferred_cuisine")
  reservation_provider   String?  @map("reservation_provider")
  reservation_url        String?  @map("reservation_url")
  ordering_provider      String?  @map("ordering_provider")
  ordering_url           String?  @map("ordering_url")
  menu_url               String?  @map("menu_url")
  social_links           Json?    @map("social_links")
  extraction_confidence  Decimal?  @map("extraction_confidence") @db.Decimal(4, 2)
  last_updated_at        DateTime @default(now()) @updatedAt @map("last_updated_at")

  entities entities @relation(fields: [entityId], references: [id], onDelete: Cascade)
}

/// Place appearances — subject (pop-up/mobile) appears at host place OR raw location (sidewalk)
/// Constraint: either hostPlaceId IS NOT NULL OR (latitude AND longitude AND addressText) all present
enum PlaceAppearanceStatus {
  ACTIVE
  ENDED
  ANNOUNCED
}

model place_appearances {
  id               String                 @id @default(uuid())
  subjectEntityId  String                 @map("subject_entity_id")
  hostEntityId     String?                @map("host_entity_id")
  latitude         Decimal?               @db.Decimal(10, 8)
  longitude        Decimal?               @db.Decimal(11, 8)
  addressText      String?                @map("address_text") @db.Text
  scheduleText     String                 @map("schedule_text") @db.Text
  status           PlaceAppearanceStatus  @default(ACTIVE)
  sources          Json?
  confidence       Float?
  createdAt        DateTime               @default(now()) @map("created_at")
  updatedAt        DateTime               @updatedAt @map("updated_at")

  subjectEntity entities @relation("AppearanceSubject", fields: [subjectEntityId], references: [id], onDelete: Cascade)
  hostEntity    entities? @relation("AppearanceHost", fields: [hostEntityId], references: [id], onDelete: SetNull)

  @@index([subjectEntityId, status])
  @@index([hostEntityId, status])
  @@map("place_appearances")
}

model restaurant_groups {
  id                      String     @id
  name                    String
  slug                    String     @unique
  visibility              Visibility
  description             String?
  anchor_city             String?
  website                 String?
  location_count_estimate Int?
  sources                 Json
  created_at              DateTime   @default(now())
  updated_at              DateTime
  people                  people[]
  entities                entities[]

  @@index([slug])
  @@index([visibility])
}

model users {
  id                   String                 @id
  email                String                 @unique
  name                 String?
  passwordHash         String?                @map("password_hash")
  avatarUrl            String?                @map("avatar_url")
  subscriptionTier     String                 @default("free") @map("subscription_tier")
  curatorNote          String?                @map("curator_note") @db.VarChar(140)
  scopePills           String[]               @default([]) @map("scope_pills")
  coverageSources      String[]               @default([]) @map("coverage_sources")
  createdAt            DateTime               @default(now()) @map("created_at")
  updatedAt            DateTime               @map("updated_at")
  import_jobs          import_jobs[]
  lists                lists[]
  viewer_bookmarks     viewer_bookmarks[]
  saved_maps           saved_maps[]
  password_reset_tokens password_reset_tokens[]

  @@index([email])
}

model password_reset_tokens {
  id         String    @id @default(cuid())
  userId     String    @map("user_id")
  tokenHash  String    @map("token_hash")
  expiresAt  DateTime  @map("expires_at")
  usedAt     DateTime? @map("used_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  users      users     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model saved_maps {
  id      String   @id @default(cuid())
  userId  String   @map("user_id")
  listId  String   @map("list_id")
  savedAt DateTime @default(now()) @map("saved_at")
  users   users    @relation(fields: [userId], references: [id], onDelete: Cascade)
  lists   lists    @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@unique([userId, listId])
  @@index([userId])
  @@index([listId])
}

model viewer_bookmarks {
  id           String   @id
  viewerUserId String?  @map("viewer_user_id")
  entityId     String   @map("entity_id")
  visited      Boolean  @default(false)
  personalNote String?  @map("personal_note")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @map("updated_at")
  entities     entities @relation(fields: [entityId], references: [id], onDelete: Cascade)
  users        users?   @relation(fields: [viewerUserId], references: [id], onDelete: Cascade)

  @@unique([viewerUserId, entityId])
  @@index([entityId])
  @@index([viewerUserId])
}

model place_photo_eval {
  id                    String             @id @default(cuid())
  entityId              String             @map("entity_id")
  google_place_id       String             @map("google_place_id")
  photo_ref             String             @map("photo_ref")
  width_px              Int                @map("width_px")
  height_px             Int                @map("height_px")
  requested_max_width_px Int               @default(1600) @map("requested_max_width_px")
  tier                  PlacePhotoEvalTier
  type                  PlacePhotoEvalType? @map("type")
  created_at            DateTime           @default(now()) @map("created_at")
  updated_at            DateTime           @updatedAt @map("updated_at")
  entities              entities           @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, photo_ref])
  @@index([entityId])
}

enum PlacePhotoEvalTier {
  HERO
  GALLERY
  REJECT
}

enum PlacePhotoEvalType {
  EXTERIOR
  INTERIOR
  CONTEXT
  FOOD
}

enum LayerType {
  SKATE
  SURF
}

enum MapStatus {
  DRAFT
  READY
  PUBLISHED
  ARCHIVED
}

enum OrganizingLogic {
  TIME_BASED
  NEIGHBORHOOD_BASED
  ROUTE_BASED
  PURPOSE_BASED
  LAYERED
}

enum PersonPlaceRole {
  EXECUTIVE_CHEF
  OWNER
  FOUNDER
  FORMER_CHEF
  PARTNER
  OPERATOR
}

enum PersonRole {
  CHEF
  OWNER
  OPERATOR
  FOUNDER
  PARTNER
}

enum PlaceStatus {
  OPEN
  CLOSED
  PERMANENTLY_CLOSED
}

enum SpotSource {
  OSM
  CITY_DATA
  EDITORIAL
  COMMUNITY
}

enum Visibility {
  INTERNAL
  VERIFIED
}

enum PlaceType {
  venue
  activity
  public
}

enum PrimaryVertical {
  EAT
  COFFEE
  WINE
  DRINKS
  SHOP
  CULTURE
  NATURE
  STAY
  WELLNESS
  BAKERY
  PURVEYORS
  ACTIVITY
}

// ============================================================================
// ENTITY RESOLUTION SYSTEM
// New MDM (Master Data Management) tables for multi-source data integration
// ============================================================================

/// Raw records from all sources - never overwrite, always append
model raw_records {
  raw_id String @id @default(uuid())

  // Source identification
  source_name String // 'google_places', 'editorial_eater', 'editorial_infatuation', 'foursquare', 'saiko_ai', 'saiko_seed'
  external_id String? // ID from the source (e.g., Google Place ID)
  source_url  String? // Original article/page URL for editorial

  // Golden-first intake (Ken spec)
  intake_batch_id String?   @map("intake_batch_id")
  source_type     String?   @map("source_type") // e.g. 'editorial', 'csv', 'seed'
  imported_at     DateTime? @map("imported_at")

  // Standardized identifiers for blocking/matching
  placekey        String? // Placekey if available
  h3_index_r9     BigInt? // H3 hexagon at resolution 9 (~0.1 km²)
  h3_neighbors_r9 BigInt[] // K-ring neighbors for edge cases

  // The raw data
  raw_json Json // Full blob exactly as received

  // Extracted fields for indexing (denormalized for query performance)
  name_normalized String?
  lat             Decimal? @db.Decimal(10, 7)
  lng             Decimal? @db.Decimal(11, 7)

  // Metadata
  observed_at  DateTime?
  ingested_at  DateTime  @default(now())
  is_processed Boolean   @default(false)

  // Relations
  entity_links_from entity_links[]
  resolution_links   resolution_links[]
  review_queue_a     review_queue[] @relation("ReviewQueueRecordA")
  review_queue_b     review_queue[] @relation("ReviewQueueRecordB")

  @@unique([source_name, external_id])
  @@index([h3_index_r9])
  @@index([placekey])
  @@index([is_processed])
  @@index([name_normalized])
  @@index([intake_batch_id])
}

/// Entity links - maps raw records to canonical entities
model entity_links {
  canonical_id String
  raw_id       String

  // Match metadata
  match_confidence Decimal? @db.Decimal(4, 3) // 0.000 to 1.000
  match_method     String // 'placekey_exact', 'dedupe_ml', 'manual_review', 'seed_record'
  match_features   Json? // Feature scores that led to this match

  // Lifecycle
  is_active Boolean  @default(true)
  linked_at DateTime @default(now())
  linked_by String? // 'system', 'manual:bobby', etc.

  // Relations
  raw_record    raw_records    @relation(fields: [raw_id], references: [raw_id])
  golden_record golden_records @relation(fields: [canonical_id], references: [canonical_id])

  @@id([canonical_id, raw_id])
  @@index([raw_id])
  @@index([canonical_id])
  @@index([match_method])
}

/// Golden records - the computed "truth" that the app queries
model golden_records {
  canonical_id String @id @default(uuid())

  // Identifiers
  placekey        String? @unique
  google_place_id String?
  slug            String  @unique

  // Core fields (computed from survivorship rules)
  name         String
  name_display String?

  // Location
  lat            Decimal? @db.Decimal(10, 7)
  lng            Decimal? @db.Decimal(11, 7)
  address_street String?
  address_city   String?
  address_state  String?
  address_zip    String?
  neighborhood   String?

  // Classification
  category    String?
  cuisines    String[]
  price_level Int?

  // Contact
  phone            String?
  website          String?
  instagram_handle String?

  // Website provenance (website-only; no enrichment logic yet)
  website_source       String?  // Source enum: defined in next step
  website_source_class String?  // first_party | third_party | ai_inferred
  website_confidence   Decimal? @db.Decimal(3, 2) // 0.00–1.00
  website_updated_at   DateTime?

  // Hours
  hours_json      Json?
  hours_irregular Boolean @default(false)

  // Editorial enrichment
  description       String?
  vibe_tags         String[]
  signature_dishes  String[]
  pro_tips          String[]
  pull_quote        String?
  pull_quote_source String?
  pull_quote_url    String?

  // Status
  business_status String @default("operational") // 'operational', 'closed_temporarily', 'closed_permanently'

  // Lifecycle Management
  lifecycle_status LifecycleStatus @default(ACTIVE) @map("lifecycle_status")
  archive_reason   ArchiveReason?  @map("archive_reason")
  archived_at      DateTime?       @map("archived_at")
  archived_by      String?         @map("archived_by")

  // Provenance (which source won each field)
  source_attribution Json
  
  // Confidence-resolved provenance (v2)
  provenance_v2 Json?

  // Metadata
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt
  last_resolved_at DateTime?
  enriched_at      DateTime? // Last attempted enrichment (success or failure)

  // Geographic scope (for selective enrichment)
  county String? // 'Los Angeles', 'Orange', 'San Diego', etc.

  // Quality signals
  data_completeness Decimal? @db.Decimal(3, 2) // 0.00 to 1.00
  source_count      Int      @default(1)

  // Golden-first intake (Ken spec): gated promotion
  confidence       Float?   // 0–1, set by resolver
  promotion_status PromotionStatus @default(PENDING) @map("promotion_status")

  // Merge quality & field-level provenance (sources table + batch recompute)
  match_confidence  Float?  @map("match_confidence")   // 0–1, resolution confidence
  merge_quality     Float?  @map("merge_quality")      // 0–1, overall merge quality
  field_confidences Json?   @map("field_confidences")  // critical fields only: name, address, lat, lng, phone, website, hours, category, instagram, etc.
  winner_sources    Json?   @map("winner_sources")     // field -> source slug (references sources.slug)
  field_conflicts   Json?   @map("field_conflicts")    // array of field names that had conflicts

  // Menu & Wine List Scraper Fields
  menu_url            String? // Discovered menu page URL
  menu_source_url     String? // Page where menu link was found
  menu_raw_text       String? // Extracted menu content for AI processing
  winelist_url        String? // Discovered wine list URL
  winelist_source_url String? // Page where wine list link was found
  winelist_raw_text   String? // Extracted wine list content
  about_copy          String? // "Our Story" / "About Us" content
  about_source_url    String? // URL of about page
  scraped_at          DateTime? // Last successful scrape timestamp
  scrape_status       String? // 'success' | 'partial' | 'blocked' | 'timeout' | 'failed'

  // Identity Signal Fields (AI-extracted from scraped content)
  cuisine_posture      String? // produce-driven | protein-centric | carb-forward | seafood-focused | balanced
  service_model        String? // tasting-menu | a-la-carte | small-plates | family-style | counter
  price_tier           String? // $ | $$ | $$$ | $$$$
  wine_program_intent  String? // natural | classic | eclectic | minimal | none
  place_personality    String? // neighborhood-joint | destination | chef-driven | scene | hidden-gem | institution
  identity_signals     Json? // Extended signals: signature_dishes, key_producers, vibe_words, etc.
  signals_generated_at DateTime? // When signals were extracted
  signals_version      Int? // Increment when extraction prompt changes
  signals_reviewed     Boolean   @default(false)
  signals_reviewed_by  String?
  signals_reviewed_at  DateTime?

  // Voice Engine v2.0 — Tagline Fields
  tagline              String?
  tagline_candidates   String[]  @default([])
  tagline_pattern      String? // 'food' | 'neighborhood' | 'vibe' | 'authority'
  tagline_generated_at DateTime?
  tagline_signals      Json? // Snapshot of identity signals used for generation
  tagline_version      Int? // Voice engine version (2)

  // Google Places "About" attributes (structured JSONB)
  google_places_attributes            Json?
  google_places_attributes_fetched_at DateTime?

  // Energy + Formality scoring (pipeline-generated, auditable)
  energy_score         Int?      // 0–100
  energy_confidence    Float?    // 0–1
  energy_version       String?   // e.g. "energy_v1_locked"
  energy_computed_at   DateTime?
  formality_score      Int?
  formality_confidence Float?
  formality_version    String?
  formality_computed_at DateTime?

  // Relations
  entity_links      entity_links[]
  resolution_links  resolution_links[]
  review_queue      review_queue[]
  provenance        provenance[]
  menu_signals      menu_signals?
  winelist_signals  winelist_signals?
  entityActorRelationships EntityActorRelationship[]
  fieldsMemberships FieldsMembership[]
  traceSignalsCache TraceSignalsCache?

  @@index([neighborhood])
  @@index([category])
  @@index([business_status])
  @@index([slug])
  @@index([promotion_status])
}

/// Resolution links - audit trail for raw → golden resolution (Ken spec)
model resolution_links {
  id               String          @id @default(uuid())
  raw_record_id    String          @map("raw_record_id")
  golden_record_id String?         @map("golden_record_id") // null when resolution_type = ambiguous
  resolution_type  ResolutionType  @map("resolution_type")
  confidence       Float?
  match_method     MatchMethod     @map("match_method")
  resolver_version String?         @map("resolver_version")
  created_at       DateTime        @default(now()) @map("created_at")

  raw_record    raw_records     @relation(fields: [raw_record_id], references: [raw_id])
  golden_record golden_records? @relation(fields: [golden_record_id], references: [canonical_id])

  @@index([raw_record_id])
  @@index([golden_record_id])
  @@index([resolution_type])
}

/// Review queue - human-in-the-loop for ambiguous matches
model review_queue {
  queue_id String @id @default(uuid())

  // What's being reviewed
  canonical_id String?
  raw_id_a     String
  raw_id_b     String?

  // Conflict details
  conflict_type      String // 'low_confidence_match', 'attribute_mismatch', 'potential_duplicate', 'new_entity'
  match_confidence   Decimal? @db.Decimal(4, 3)
  conflicting_fields Json?

  // Review workflow
  priority         Int     @default(5) // 1 (urgent) to 10 (low)
  status           String  @default("pending") // 'pending', 'in_progress', 'resolved', 'deferred', 'flagged'
  resolution       String? // 'merged', 'kept_separate', 'new_canonical', 'dismissed'
  resolution_notes String?

  // Audit
  created_at  DateTime  @default(now())
  assigned_to String?
  resolved_by String?
  resolved_at DateTime?

  // Relations
  golden_record golden_records?    @relation(fields: [canonical_id], references: [canonical_id])
  raw_record_a  raw_records        @relation("ReviewQueueRecordA", fields: [raw_id_a], references: [raw_id])
  raw_record_b  raw_records?       @relation("ReviewQueueRecordB", fields: [raw_id_b], references: [raw_id])
  audit_logs    review_audit_log[]

  @@index([status])
  @@index([priority, status])
  @@index([canonical_id])
}

/// Audit trail for review decisions
model review_audit_log {
  log_id           String   @id @default(uuid())
  queue_id         String
  resolved_by      String
  resolution       String
  decision_time_ms Int?
  resolved_at      DateTime @default(now())

  // Relations
  review_queue review_queue @relation(fields: [queue_id], references: [queue_id])

  @@index([queue_id])
  @@index([resolved_at])
}

// ============================================================================
// SOURCES REGISTRY (trust tiers + domain for merge / winner_sources)
// ============================================================================

// Confidence System v1: trust tiers 0–1, editable in DB (not hardcoded)
model sources {
  id         String   @id // e.g. 'google_places', 'michelin' — editable trust tiers
  name       String
  trust_tier Float    @map("trust_tier") // 0–1, CHECK in DB
  domain     String[] @default([]) // optional domains for validation
  created_at DateTime @default(now()) @map("created_at")

  @@index([trust_tier])
}

// ============================================================================
// PROVENANCE SYSTEM
// Chain of custody - proves Bobby added every place, not AI
// ============================================================================

/// Provenance - Chain of custody for places
model provenance {
  id       String @id @default(cuid())
  place_id String @map("place_id")

  // WHO - Chain of custody (NEVER 'claude', 'cursor', 'ai', 'auto', 'bot')
  added_by String @map("added_by") // 'bobby', 'bobby_bulk_import'

  // WHY - Source justification (flexible, not enforced)
  source_type String?   @map("source_type") // 'editorial', 'google_saves', 'chef_rec', 'video', 'personal', 'map_feature'
  source_name String?   @map("source_name") // 'Eater LA', 'Jonathan Gold', 'Bobby Google Saves', 'Chef David Chang'
  source_url  String?   @map("source_url") // article/video link if available
  source_date DateTime? @map("source_date") // when the source was published (if known)

  // CONTEXT
  notes String? // freeform: "Mentioned in 'Best Tacos' video", "My go-to since 2019"

  // BATCH TRACKING
  import_batch String? @map("import_batch") // 'sgv_expansion', 'beach_cities', 'initial_google_saves', 'sfv_expansion'

  // SOURCE QUALITY & VERIFICATION
  source_tier         Int?               @map("source_tier") // 1, 2, 3, or 4
  verification_status VerificationStatus @default(UNVERIFIED) @map("verification_status")
  source_verified_at  DateTime?          @map("source_verified_at")
  source_verified_by  String?            @map("source_verified_by")

  // TIMESTAMPS
  created_at DateTime @default(now()) @map("created_at")

  // RELATIONS
  golden_record golden_records @relation(fields: [place_id], references: [canonical_id], onDelete: Cascade)

  @@index([place_id])
  @@index([added_by])
  @@index([import_batch])
}

// ============================================================================
// ENUMS FOR LIFECYCLE AND VERIFICATION
// ============================================================================

enum LifecycleStatus {
  ACTIVE
  LEGACY_FAVORITE
  FLAG_FOR_REVIEW
  ARCHIVED
  CLOSED_PERMANENTLY
}

// Golden-first intake (Ken spec)
enum PromotionStatus {
  PENDING
  VERIFIED
  PUBLISHED
}

enum ResolutionType {
  matched
  created
  ambiguous
}

enum MatchMethod {
  exact
  normalized
  fuzzy
}

enum ArchiveReason {
  CLOSED
  AGED_OUT
  QUALITY_DECLINE
  DATA_ERROR
  MANUAL
}

enum VerificationStatus {
  UNVERIFIED
  SOURCE_CONFIRMED
  FOUNDER_VERIFIED
}

enum signal_status {
  ok
  partial
  failed
}

// ============================================================================
// NEWSLETTER INGESTION — APPROVAL FRAMEWORK V1
// Two-table hybrid for operator-derived operational deltas
// ============================================================================

enum SignalSourceType {
  newsletter_email
}

enum ProposedSignalType {
  closure
  hours_override
  event
  recurring_program
  uncertainty
}

enum ProposedSignalStatus {
  proposed
  approved
  rejected
  superseded
}

enum OverlayType {
  closure
  hours_override
  event
  uncertainty
}

enum OverlayApprovalMethod {
  manual
}

/// Proposed signals - immutable extraction records from newsletters
model proposed_signals {
  id                String               @id @default(cuid())
  placeId           String               @map("place_id")
  sourceType        SignalSourceType     @map("source_type")
  sourceId          String               @map("source_id") // email message-id or stored email record id
  signalType        ProposedSignalType   @map("signal_type")
  extractedData     Json                 @map("extracted_data")
  confidenceScore   Float?               @map("confidence_score")
  evidenceExcerpt   String?              @map("evidence_excerpt")
  status            ProposedSignalStatus @default(proposed)
  createdAt         DateTime             @default(now()) @map("created_at")
  updatedAt         DateTime             @updatedAt @map("updated_at")
  
  // Relations
  operational_overlay operational_overlays?

  @@index([placeId])
  @@index([status])
  @@index([signalType])
  @@index([createdAt])
}

/// Operational overlays - approved, time-bounded state
model operational_overlays {
  id              String                 @id @default(cuid())
  placeId         String                 @map("place_id")
  sourceSignalId  String                 @unique @map("source_signal_id")
  overlayType     OverlayType            @map("overlay_type")
  startsAt        DateTime               @map("starts_at")
  endsAt          DateTime               @map("ends_at")
  overrideData    Json?                  @map("override_data")
  approvalMethod  OverlayApprovalMethod  @default(manual) @map("approval_method")
  createdAt       DateTime               @default(now()) @map("created_at")

  // Relations
  proposed_signal proposed_signals @relation(fields: [sourceSignalId], references: [id])

  @@index([placeId])
  @@index([startsAt])
  @@index([endsAt])
}

// ============================================================================
// SIGNAL EXTRACTION SYSTEM
// AI analysis of scraped menu + winelist content
// ============================================================================

/// Menu signals - structured analysis of menu_raw_text
model menu_signals {
  id                String         @id @default(cuid())
  golden_record_id  String         @unique
  golden_record     golden_records @relation(fields: [golden_record_id], references: [canonical_id], onDelete: Cascade)

  schema_version    Int            @default(1)
  model_version     String?
  source_scraped_at DateTime?
  analyzed_at       DateTime       @default(now())
  status            signal_status  @default(ok)
  error             String?

  payload           Json?
  evidence          Json?
  confidence        Float?

  created_at        DateTime       @default(now())
  updated_at        DateTime       @updatedAt

  @@map("menu_signals")
  @@index([analyzed_at])
  @@index([status])
}

/// Winelist signals - structured analysis of winelist_raw_text
model winelist_signals {
  id                String         @id @default(cuid())
  golden_record_id  String         @unique
  golden_record     golden_records @relation(fields: [golden_record_id], references: [canonical_id], onDelete: Cascade)

  schema_version    Int            @default(1)
  model_version     String?
  source_scraped_at DateTime?
  analyzed_at       DateTime       @default(now())
  status            signal_status  @default(ok)
  error             String?

  payload           Json?
  evidence          Json?
  confidence        Float?

  created_at        DateTime       @default(now())
  updated_at        DateTime       @updatedAt

  @@map("winelist_signals")
  @@index([analyzed_at])
  @@index([status])
}

// ============================================================================
// ENERGY + WEIGHTED TAG ENGINE (v1)
// CTO Spec: deterministic, versioned classification system
// ============================================================================

/// energy_versions — version metadata for energy engine
model energy_versions {
  version      String          @id
  weights      Json?
  lexicon_hash String?         @map("lexicon_hash")
  created_at   DateTime        @default(now()) @map("created_at")

  energy_scores energy_scores[]
  tag_versions  tag_versions[]
}

/// tag_versions — version metadata for tag scoring engine
model tag_versions {
  version                  String @id
  tag_weight_config        Json?  @map("tag_weight_config")
  depends_on_energy_version String @map("depends_on_energy_version")
  created_at               DateTime @default(now()) @map("created_at")

  energy_version   energy_versions @relation(fields: [depends_on_energy_version], references: [version])
  place_tag_scores place_tag_scores[]
}

/// energy_scores — baseline environmental stimulation per entity
model energy_scores {
  id                    String   @id @default(uuid())
  entityId              String   @map("entity_id")
  energy_score          Int
  energy_confidence     Float
  popularity_component  Int?     @map("popularity_component")
  language_component    Int?     @map("language_component")
  flags_component       Int?     @map("flags_component")
  sensory_component     Int?     @map("sensory_component")
  has_popularity        Boolean  @default(false) @map("has_popularity")
  has_language          Boolean  @default(false) @map("has_language")
  has_flags             Boolean  @default(false) @map("has_flags")
  has_sensory           Boolean  @default(false) @map("has_sensory")
  version               String
  computed_at           DateTime @default(now()) @map("computed_at")

  entity  entities      @relation(fields: [entityId], references: [id], onDelete: Cascade)
  energy_version energy_versions @relation(fields: [version], references: [version])

  @@unique([entityId, version])
  @@index([entityId])
  @@index([version])
}

/// place_tag_scores — weighted tag interpretations (0-1) per entity
model place_tag_scores {
  id                       String   @id @default(uuid())
  entityId                 String   @map("entity_id")
  cozy_score               Float
  date_night_score         Float    @map("date_night_score")
  late_night_score         Float    @map("late_night_score")
  after_work_score         Float    @map("after_work_score")
  scene_score              Float    @map("scene_score")
  confidence               Float?
  version                  String
  depends_on_energy_version String   @map("depends_on_energy_version")
  computed_at              DateTime @default(now()) @map("computed_at")

  entity  entities     @relation(fields: [entityId], references: [id], onDelete: Cascade)
  tag_version tag_versions @relation(fields: [version], references: [version])

  @@unique([entityId, version])
  @@index([entityId])
  @@index([version])
}

// ============================================================================
// SAIKO FIELDS + SAIKO TRACE v0.2
// Fields = curated index layer; Trace = signal computation layer
// ============================================================================

enum ActorKind {
  organization
  operator
  brand
  person
  collective
}

enum ActorRole {
  operator
  owner
  founder
  brand
  parent
  collective
}

/// Actors - canonical identity (Saiko Fields relationship layer).
/// Migrated from restaurant_groups (kind=operator).
model Actor {
  id          String     @id @default(uuid())
  name        String
  kind        ActorKind  @default(operator)
  slug        String?    @unique
  website     String?
  description String?
  visibility  Visibility?
  sources     Json?
  confidence  Float?
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")

  entityRelationships   EntityActorRelationship[]
  placeActorRelationships PlaceActorRelationship[]
  operatorPlaceCandidates OperatorPlaceCandidate[]

  @@index([name])
  @@index([slug])
}

/// Operator → Place link candidates (human review). Idempotent on (actor_id, candidate_url) or (actor_id, candidate_name, candidate_address).
enum OperatorPlaceCandidateStatus {
  PENDING
  APPROVED
  REJECTED
  STALE
}

enum ConfidenceBucket {
  HIGH
  MEDIUM
  LOW
}

model OperatorPlaceCandidate {
  id                String                        @id @default(uuid())
  actorId           String                        @map("actor_id")
  entityId          String?                       @map("entity_id")
  candidateName     String                        @map("candidate_name")
  candidateUrl      String?                       @map("candidate_url")
  candidateAddress  String?                       @map("candidate_address")
  sourceUrl         String                        @map("source_url")
  matchScore        Float                         @default(0) @map("match_score")
  matchReason       String?                       @map("match_reason")
  status            OperatorPlaceCandidateStatus @default(PENDING)
  rejectionReason   String?                       @map("rejection_reason")
  reviewedAt        DateTime?                     @map("reviewed_at")
  approvedBy        String?                       @map("approved_by")
  confidenceBucket  ConfidenceBucket?             @map("confidence_bucket")
  createdAt         DateTime                     @default(now()) @map("created_at")
  updatedAt         DateTime                     @updatedAt @map("updated_at")

  actor  Actor     @relation(fields: [actorId], references: [id], onDelete: Cascade)
  entity entities? @relation(fields: [entityId], references: [id], onDelete: SetNull)

  @@index([actorId, status])
  @@index([entityId])
  @@map("operator_place_candidates")
}

/// Entity-Actor relationships (Saiko Trace)
/// Canonical for golden_records. Do not use for app-facing Place UI.
model EntityActorRelationship {
  id         String    @id @default(uuid())
  entityId   String    @map("entity_id")
  actorId    String    @map("actor_id")
  role       ActorRole
  confidence Float?
  source     String?
  startDate  DateTime? @map("start_date")
  endDate    DateTime? @map("end_date")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  entity golden_records @relation(fields: [entityId], references: [canonical_id], onDelete: Cascade)
  actor  Actor          @relation(fields: [actorId], references: [id], onDelete: Cascade)

  @@index([entityId])
  @@index([actorId])
}

/// Place-Actor relationships — app-facing projection layer.
/// Materialized when place ↔ golden exists; temporary canonical when place has no golden.
/// Written only by ingestion/sync logic. UI reads from here.
///
/// Note: @@unique([placeId, actorId, role]) prevents duplicate rows but does NOT enforce
/// "at most one isPrimary=true per (place, role)". Later consider a partial unique index
/// e.g. UNIQUE (place_id) WHERE is_primary AND role = 'operator'.
model PlaceActorRelationship {
  id         String    @id @default(cuid())
  entityId   String    @map("entity_id")
  actorId    String    @map("actor_id")
  role       ActorRole
  isPrimary  Boolean   @default(false) @map("is_primary")
  startDate  DateTime? @map("start_date")
  endDate    DateTime? @map("end_date")
  sources    Json?
  confidence Float?
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  entity entities @relation(fields: [entityId], references: [id], onDelete: Cascade)
  actor  Actor    @relation(fields: [actorId], references: [id], onDelete: Cascade)

  @@unique([entityId, actorId, role])
  @@index([entityId])
  @@index([actorId])
  @@map("place_actor_relationships")
}

/// Fields membership - entities in the curated index (Saiko Fields)
model FieldsMembership {
  id         String    @id @default(uuid())
  entityId   String    @map("entity_id")
  includedAt DateTime  @map("included_at")
  removedAt  DateTime? @map("removed_at")
  curatorId  String?   @map("curator_id")
  reason     String?
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  entity golden_records @relation(fields: [entityId], references: [canonical_id], onDelete: Cascade)

  @@index([entityId])
}

/// Trace signals cache - one row per entity, latest only (Saiko Trace)
model TraceSignalsCache {
  id         String   @id @default(uuid())
  entityId   String   @unique @map("entity_id")
  computedAt DateTime @map("computed_at")
  signals    Json
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  entity golden_records @relation(fields: [entityId], references: [canonical_id], onDelete: Cascade)

  @@index([entityId])
}

// ============================================================================
// COVERAGE RUN LEDGER
// Idempotency + dedupe for coverage enrichment pipeline
// ============================================================================

/// coverage_runs — metadata for each coverage audit/run
model coverage_runs {
  id        String   @id @default(uuid())
  created_at DateTime @default(now()) @map("created_at")
  db_host   String   @map("db_host")
  db_name   String   @map("db_name")
  git_sha   String?  @map("git_sha")
  limit_val Int?     @map("limit_val")
  la_only   Boolean  @default(true) @map("la_only")
  ttl_days  Int?     @map("ttl_days")

  @@map("coverage_runs")
}

// ============================================================================
// GPID RESOLUTION QUEUE (Identity Queue v1)
// Human-in-the-loop for unresolved Google Place ID matches
// Extensible: later add enrichment_queue, data_completion_queue as separate queue types
// ============================================================================

enum GpidResolverStatus {
  MATCH
  AMBIGUOUS
  NO_MATCH
  ERROR
}

enum GpidHumanStatus {
  PENDING
  APPROVED
  REJECTED
  NEEDS_MORE_INFO
}

enum GpidHumanDecision {
  APPLY_GPID
  MARK_NO_MATCH
  MARK_AMBIGUOUS
}

model gpid_resolution_queue {
  id                 String            @id @default(uuid())
  entityId           String            @map("entity_id")
  candidate_gpid     String?           @map("candidate_gpid") // best single candidate (for MATCH)
  resolver_status    GpidResolverStatus @map("resolver_status")
  reason_code        String?           @map("reason_code") // TEXT_LOW_SIM, TEXT_MULTI_RESULTS, etc.
  similarity_score   Float?            @map("similarity_score") // 0-100
  candidates_json    Json?             @map("candidates_json") // all candidates + meta
  source_run_id      String?           @map("source_run_id")
  created_at         DateTime          @default(now()) @map("created_at")
  updated_at         DateTime          @updatedAt @map("updated_at")

  // Human review
  human_status       GpidHumanStatus    @default(PENDING) @map("human_status")
  human_decision     GpidHumanDecision? @map("human_decision")
  human_note         String?            @map("human_note")
  reviewed_by        String?            @map("reviewed_by")
  reviewed_at        DateTime?          @map("reviewed_at")

  entities           entities          @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@index([human_status])
  @@index([resolver_status])
  @@index([entityId])
  @@index([reason_code])
  @@map("gpid_resolution_queue")
}

/// place_coverage_status — per-dedupe_key coverage state (no double spend)
model place_coverage_status {
  id                  String   @id @default(cuid())
  entityId            String   @map("entity_id")
  dedupe_key          String   @unique @map("dedupe_key") // google_place_id or entity_id
  last_success_at     DateTime? @map("last_success_at")
  last_attempt_at     DateTime? @map("last_attempt_at")
  last_attempt_status String?  @map("last_attempt_status") // SUCCESS | FAIL | RUNNING
  last_error_code     String?  @map("last_error_code")
  last_error_message  String?  @map("last_error_message")
  last_missing_groups Json?    @map("last_missing_groups") // string[]
  source              String?  // GOOGLE_PLACES | SCRAPE | MANUAL
  updated_at          DateTime @updatedAt @map("updated_at")

  entities entities @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@index([entityId])
  @@index([last_attempt_status])
  @@map("place_coverage_status")
}

// ============================================================================
// PLACE JOB LOG — cost/metric audit (identity, operator_link, scan jobs)
// No UI. Minimal fields for pages_fetched, ai_calls, duration_ms, estimated_cost.
// ============================================================================

model place_job_log {
  id              String   @id @default(uuid())
  entity_id       String   @map("entity_id")
  entity_type     String   @map("entity_type") // 'place' | 'actor' | 'golden_record' | 'batch'
  job_type        String   @map("job_type")    // 'IDENTITY' | 'OPERATOR_LINK' | 'SCAN'
  pages_fetched   Int      @default(0) @map("pages_fetched")
  ai_calls        Int      @default(0) @map("ai_calls")
  duration_ms     Int?     @map("duration_ms")
  estimated_cost  Decimal? @map("estimated_cost") @db.Decimal(10, 6)
  created_at      DateTime @default(now()) @map("created_at")

  @@index([entity_id])
  @@index([job_type])
  @@index([created_at])
  @@map("place_job_log")
}
